"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/arcade/page",{

/***/ "(app-pages-browser)/./lib/games/zipPuzzle/ZipPuzzleLogic.ts":
/*!***********************************************!*\
  !*** ./lib/games/zipPuzzle/ZipPuzzleLogic.ts ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useZipPuzzleEngine: function() { return /* binding */ useZipPuzzleEngine; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst keyOf = (point)=>\"\".concat(point.row, \"-\").concat(point.col);\nclass ZipPuzzleEngine {\n    setPuzzle(puzzle, signature) {\n        this.anchors = [\n            ...puzzle.anchors\n        ].sort((a, b)=>a.value - b.value);\n        this.anchorKeys = this.anchors.map((anchor)=>keyOf(anchor));\n        this.anchorsByKey = new Map(this.anchors.map((anchor)=>[\n                keyOf(anchor),\n                anchor\n            ]));\n        this.size = puzzle.size;\n        this.totalCells = this.size * this.size;\n        this.path = [];\n        this.visited = new Set();\n        this.anchorIndex = -1;\n        this.status = \"idle\";\n        this.hasBacktracked = false;\n        this.signature = signature;\n    }\n    isAdjacent(a, b) {\n        return Math.abs(a.row - b.row) + Math.abs(a.col - b.col) === 1;\n    }\n    ensureStart(point) {\n        const firstAnchor = this.anchors[0];\n        if (!firstAnchor) return {\n            changed: false\n        };\n        if (firstAnchor.row !== point.row || firstAnchor.col !== point.col) {\n            return {\n                changed: false,\n                invalidKey: keyOf(point)\n            };\n        }\n        this.path = [\n            point\n        ];\n        this.visited = new Set([\n            keyOf(point)\n        ]);\n        this.anchorIndex = 0;\n        this.status = this.totalCells === 1 ? \"won\" : \"active\";\n        return {\n            changed: true\n        };\n    }\n    recomputeAnchors() {\n        this.anchorIndex = -1;\n        this.path.forEach((point)=>{\n            const anchorIdx = this.anchorKeys.indexOf(keyOf(point));\n            if (anchorIdx !== -1 && anchorIdx === this.anchorIndex + 1) {\n                this.anchorIndex = anchorIdx;\n            }\n        });\n    }\n    resetVisitedFromPath() {\n        this.visited = new Set(this.path.map((point)=>keyOf(point)));\n    }\n    visit(point) {\n        if (point.row < 0 || point.col < 0 || point.row >= this.size || point.col >= this.size) {\n            return {\n                changed: false\n            };\n        }\n        if (!this.path.length) {\n            return this.ensureStart(point);\n        }\n        const last = this.path[this.path.length - 1];\n        if (last.row === point.row && last.col === point.col) {\n            return {\n                changed: false\n            };\n        }\n        if (!this.isAdjacent(last, point)) {\n            return {\n                changed: false,\n                invalidKey: keyOf(point)\n            };\n        }\n        const cellKey = keyOf(point);\n        if (this.visited.has(cellKey)) {\n            const lastIndex = this.path.length - 1;\n            const previousIndex = lastIndex - 1;\n            if (previousIndex >= 0) {\n                const previous = this.path[previousIndex];\n                if (previous.row === point.row && previous.col === point.col) {\n                    this.path.pop();\n                    this.resetVisitedFromPath();\n                    this.hasBacktracked = true;\n                    this.recomputeAnchors();\n                    this.status = \"active\";\n                    return {\n                        changed: true\n                    };\n                }\n            }\n            return {\n                changed: false,\n                invalidKey: cellKey\n            };\n        }\n        const anchor = this.anchorsByKey.get(cellKey);\n        const nextAnchor = this.anchors[this.anchorIndex + 1];\n        if (anchor) {\n            if (!nextAnchor || anchor.value !== nextAnchor.value) {\n                return {\n                    changed: false,\n                    invalidKey: cellKey\n                };\n            }\n        }\n        this.path.push(point);\n        this.visited.add(cellKey);\n        if (anchor && nextAnchor && anchor.value === nextAnchor.value) {\n            this.anchorIndex += 1;\n        }\n        if (this.path.length === this.totalCells && this.anchorIndex === this.anchors.length - 1) {\n            this.status = \"won\";\n        } else {\n            this.status = \"active\";\n        }\n        return {\n            changed: true\n        };\n    }\n    undo() {\n        if (this.path.length <= 1) return false;\n        this.path.pop();\n        this.resetVisitedFromPath();\n        this.hasBacktracked = true;\n        this.recomputeAnchors();\n        this.status = \"active\";\n        return true;\n    }\n    getSnapshot() {\n        return {\n            path: [\n                ...this.path\n            ],\n            status: this.status,\n            hasBacktracked: this.hasBacktracked\n        };\n    }\n    constructor(puzzle, signature){\n        this.path = [];\n        this.visited = new Set();\n        this.anchorIndex = -1;\n        this.status = \"idle\";\n        this.hasBacktracked = false;\n        this.anchors = [\n            ...puzzle.anchors\n        ].sort((a, b)=>a.value - b.value);\n        this.anchorKeys = this.anchors.map((anchor)=>keyOf(anchor));\n        this.anchorsByKey = new Map(this.anchors.map((anchor)=>[\n                keyOf(anchor),\n                anchor\n            ]));\n        this.size = puzzle.size;\n        this.totalCells = this.size * this.size;\n        this.signature = signature;\n    }\n}\nconst useZipPuzzleEngine = (puzzle)=>{\n    const signature = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>JSON.stringify(puzzle), [\n        puzzle\n    ]);\n    const engineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    if (!engineRef.current) {\n        engineRef.current = new ZipPuzzleEngine(puzzle, signature);\n    } else if (engineRef.current.signature !== signature) {\n        engineRef.current.setPuzzle(puzzle, signature);\n    }\n    const visit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((point)=>{\n        var _engineRef_current;\n        const result = (_engineRef_current = engineRef.current) === null || _engineRef_current === void 0 ? void 0 : _engineRef_current.visit(point);\n        if (result === null || result === void 0 ? void 0 : result.changed) {\n            forceRender((value)=>value + 1);\n        }\n        return result;\n    }, []);\n    const undo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _engineRef_current;\n        if ((_engineRef_current = engineRef.current) === null || _engineRef_current === void 0 ? void 0 : _engineRef_current.undo()) {\n            forceRender((value)=>value + 1);\n        }\n    }, []);\n    return {\n        size: puzzle.size,\n        anchors: engineRef.current.anchors,\n        snapshot: engineRef.current.getSnapshot(),\n        visit,\n        undo\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9nYW1lcy96aXBQdXp6bGUvWmlwUHV6emxlTG9naWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStEO0FBbUIvRCxNQUFNSSxRQUFRLENBQUNDLFFBQTBCLEdBQWdCQSxPQUFiQSxNQUFNQyxHQUFHLEVBQUMsS0FBYSxPQUFWRCxNQUFNRSxHQUFHO0FBRWxFLE1BQU1DO0lBc0JKQyxVQUFVQyxNQUFxQixFQUFFQyxTQUFpQixFQUFFO1FBQ2xELElBQUksQ0FBQ0MsT0FBTyxHQUFHO2VBQUlGLE9BQU9FLE9BQU87U0FBQyxDQUFDQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUUsS0FBSyxHQUFHRCxFQUFFQyxLQUFLO1FBQ25FLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUksQ0FBQ0wsT0FBTyxDQUFDTSxHQUFHLENBQUMsQ0FBQ0MsU0FBV2YsTUFBTWU7UUFDckQsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSUMsSUFBSSxJQUFJLENBQUNULE9BQU8sQ0FBQ00sR0FBRyxDQUFDLENBQUNDLFNBQVc7Z0JBQUNmLE1BQU1lO2dCQUFTQTthQUFPO1FBQ2hGLElBQUksQ0FBQ0csSUFBSSxHQUFHWixPQUFPWSxJQUFJO1FBQ3ZCLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSTtRQUN2QyxJQUFJLENBQUNFLElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUM7UUFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsQ0FBQztRQUNwQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2xCLFNBQVMsR0FBR0E7SUFDbkI7SUFFUW1CLFdBQVdoQixDQUFpQixFQUFFQyxDQUFpQixFQUFFO1FBQ3ZELE9BQU9nQixLQUFLQyxHQUFHLENBQUNsQixFQUFFUixHQUFHLEdBQUdT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LE1BQU1DLFlBQVlWLDhDQUFPQSxDQUFDLElBQU0wRCxLQUFLQyxTQUFTLENBQUNsRCxTQUFTO1FBQUNBO0tBQU87SUFDaEUsTUFBTW1ELFlBQVkzRCw2Q0FBTUE7SUFDeEIsTUFBTSxHQUFHNEQsWUFBWSxHQUFHM0QsK0NBQVFBLENBQUM7SUFFakMsSUFBSSxDQUFDMEQsVUFBVUUsT0FBTyxFQUFFO1FBQ3RCRixVQUFVRSxPQUFPLEdBQUcsSUFBSXZELGdCQUFnQkUsUUFBUUM7SUFDbEQsT0FBTyxJQUFJa0QsVUFBVUUsT0FBTyxDQUFDcEQsU0FBUyxLQUFLQSxXQUFXO1FBQ3BEa0QsVUFBVUUsT0FBTyxDQUFDdEQsU0FBUyxDQUFDQyxRQUFRQztJQUN0QztJQUVBLE1BQU0rQixRQUFRMUMsa0RBQVdBLENBQ3ZCLENBQUNLO1lBQ2dCd0Q7UUFBZixNQUFNRyxVQUFTSCxxQkFBQUEsVUFBVUUsT0FBTyxjQUFqQkYseUNBQUFBLG1CQUFtQm5CLEtBQUssQ0FBQ3JDO1FBQ3hDLElBQUkyRCxtQkFBQUEsNkJBQUFBLE9BQVE3QixPQUFPLEVBQUU7WUFDbkIyQixZQUFZLENBQUM5QyxRQUFVQSxRQUFRO1FBQ2pDO1FBQ0EsT0FBT2dEO0lBQ1QsR0FDQSxFQUFFO0lBR0osTUFBTVQsT0FBT3ZELGtEQUFXQSxDQUFDO1lBQ25CNkQ7UUFBSixLQUFJQSxxQkFBQUEsVUFBVUUsT0FBTyxjQUFqQkYseUNBQUFBLG1CQUFtQk4sSUFBSSxJQUFJO1lBQzdCTyxZQUFZLENBQUM5QyxRQUFVQSxRQUFRO1FBQ2pDO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMTSxNQUFNWixPQUFPWSxJQUFJO1FBQ2pCVixTQUFTaUQsVUFBVUUsT0FBTyxDQUFDbkQsT0FBTztRQUNsQ3FELFVBQVVKLFVBQVVFLE9BQU8sQ0FBQ1AsV0FBVztRQUN2Q2Q7UUFDQWE7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2dhbWVzL3ppcFB1enpsZS9aaXBQdXp6bGVMb2dpYy50cz83YzA3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCB0eXBlIFppcFB1enpsZVBvaW50ID0geyByb3c6IG51bWJlcjsgY29sOiBudW1iZXIgfTtcbmV4cG9ydCB0eXBlIFppcEFuY2hvciA9IFppcFB1enpsZVBvaW50ICYgeyB2YWx1ZTogbnVtYmVyIH07XG5cbmV4cG9ydCB0eXBlIFppcFB1enpsZURhdGEgPSB7XG4gIHNpemU6IG51bWJlcjtcbiAgYW5jaG9yczogWmlwQW5jaG9yW107XG4gIHBhdGg6IFppcFB1enpsZVBvaW50W107XG59O1xuXG5leHBvcnQgdHlwZSBaaXBTbmFwc2hvdCA9IHtcbiAgcGF0aDogWmlwUHV6emxlUG9pbnRbXTtcbiAgc3RhdHVzOiBcImlkbGVcIiB8IFwiYWN0aXZlXCIgfCBcIndvblwiO1xuICBoYXNCYWNrdHJhY2tlZDogYm9vbGVhbjtcbn07XG5cbnR5cGUgVmlzaXRSZXN1bHQgPSB7IGNoYW5nZWQ6IGJvb2xlYW47IGludmFsaWRLZXk/OiBzdHJpbmcgfTtcblxuY29uc3Qga2V5T2YgPSAocG9pbnQ6IFppcFB1enpsZVBvaW50KSA9PiBgJHtwb2ludC5yb3d9LSR7cG9pbnQuY29sfWA7XG5cbmNsYXNzIFppcFB1enpsZUVuZ2luZSB7XG4gIHNpemU6IG51bWJlcjtcbiAgdG90YWxDZWxsczogbnVtYmVyO1xuICBhbmNob3JzOiBaaXBBbmNob3JbXTtcbiAgYW5jaG9yS2V5czogc3RyaW5nW107XG4gIGFuY2hvcnNCeUtleTogTWFwPHN0cmluZywgWmlwQW5jaG9yPjtcbiAgcGF0aDogWmlwUHV6emxlUG9pbnRbXSA9IFtdO1xuICB2aXNpdGVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGFuY2hvckluZGV4ID0gLTE7XG4gIHN0YXR1czogWmlwU25hcHNob3RbXCJzdGF0dXNcIl0gPSBcImlkbGVcIjtcbiAgaGFzQmFja3RyYWNrZWQgPSBmYWxzZTtcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHV6emxlOiBaaXBQdXp6bGVEYXRhLCBzaWduYXR1cmU6IHN0cmluZykge1xuICAgIHRoaXMuYW5jaG9ycyA9IFsuLi5wdXp6bGUuYW5jaG9yc10uc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpO1xuICAgIHRoaXMuYW5jaG9yS2V5cyA9IHRoaXMuYW5jaG9ycy5tYXAoKGFuY2hvcikgPT4ga2V5T2YoYW5jaG9yKSk7XG4gICAgdGhpcy5hbmNob3JzQnlLZXkgPSBuZXcgTWFwKHRoaXMuYW5jaG9ycy5tYXAoKGFuY2hvcikgPT4gW2tleU9mKGFuY2hvciksIGFuY2hvcl0pKTtcbiAgICB0aGlzLnNpemUgPSBwdXp6bGUuc2l6ZTtcbiAgICB0aGlzLnRvdGFsQ2VsbHMgPSB0aGlzLnNpemUgKiB0aGlzLnNpemU7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cblxuICBzZXRQdXp6bGUocHV6emxlOiBaaXBQdXp6bGVEYXRhLCBzaWduYXR1cmU6IHN0cmluZykge1xuICAgIHRoaXMuYW5jaG9ycyA9IFsuLi5wdXp6bGUuYW5jaG9yc10uc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpO1xuICAgIHRoaXMuYW5jaG9yS2V5cyA9IHRoaXMuYW5jaG9ycy5tYXAoKGFuY2hvcikgPT4ga2V5T2YoYW5jaG9yKSk7XG4gICAgdGhpcy5hbmNob3JzQnlLZXkgPSBuZXcgTWFwKHRoaXMuYW5jaG9ycy5tYXAoKGFuY2hvcikgPT4gW2tleU9mKGFuY2hvciksIGFuY2hvcl0pKTtcbiAgICB0aGlzLnNpemUgPSBwdXp6bGUuc2l6ZTtcbiAgICB0aGlzLnRvdGFsQ2VsbHMgPSB0aGlzLnNpemUgKiB0aGlzLnNpemU7XG4gICAgdGhpcy5wYXRoID0gW107XG4gICAgdGhpcy52aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHRoaXMuYW5jaG9ySW5kZXggPSAtMTtcbiAgICB0aGlzLnN0YXR1cyA9IFwiaWRsZVwiO1xuICAgIHRoaXMuaGFzQmFja3RyYWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxuXG4gIHByaXZhdGUgaXNBZGphY2VudChhOiBaaXBQdXp6bGVQb2ludCwgYjogWmlwUHV6emxlUG9pbnQpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS5yb3cgLSBiLnJvdykgKyBNYXRoLmFicyhhLmNvbCAtIGIuY29sKSA9PT0gMTtcbiAgfVxuXG4gIHByaXZhdGUgZW5zdXJlU3RhcnQocG9pbnQ6IFppcFB1enpsZVBvaW50KTogVmlzaXRSZXN1bHQge1xuICAgIGNvbnN0IGZpcnN0QW5jaG9yID0gdGhpcy5hbmNob3JzWzBdO1xuICAgIGlmICghZmlyc3RBbmNob3IpIHJldHVybiB7IGNoYW5nZWQ6IGZhbHNlIH07XG4gICAgaWYgKGZpcnN0QW5jaG9yLnJvdyAhPT0gcG9pbnQucm93IHx8IGZpcnN0QW5jaG9yLmNvbCAhPT0gcG9pbnQuY29sKSB7XG4gICAgICByZXR1cm4geyBjaGFuZ2VkOiBmYWxzZSwgaW52YWxpZEtleToga2V5T2YocG9pbnQpIH07XG4gICAgfVxuICAgIHRoaXMucGF0aCA9IFtwb2ludF07XG4gICAgdGhpcy52aXNpdGVkID0gbmV3IFNldChba2V5T2YocG9pbnQpXSk7XG4gICAgdGhpcy5hbmNob3JJbmRleCA9IDA7XG4gICAgdGhpcy5zdGF0dXMgPSB0aGlzLnRvdGFsQ2VsbHMgPT09IDEgPyBcIndvblwiIDogXCJhY3RpdmVcIjtcbiAgICByZXR1cm4geyBjaGFuZ2VkOiB0cnVlIH07XG4gIH1cblxuICBwcml2YXRlIHJlY29tcHV0ZUFuY2hvcnMoKSB7XG4gICAgdGhpcy5hbmNob3JJbmRleCA9IC0xO1xuICAgIHRoaXMucGF0aC5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgY29uc3QgYW5jaG9ySWR4ID0gdGhpcy5hbmNob3JLZXlzLmluZGV4T2Yoa2V5T2YocG9pbnQpKTtcbiAgICAgIGlmIChhbmNob3JJZHggIT09IC0xICYmIGFuY2hvcklkeCA9PT0gdGhpcy5hbmNob3JJbmRleCArIDEpIHtcbiAgICAgICAgdGhpcy5hbmNob3JJbmRleCA9IGFuY2hvcklkeDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRWaXNpdGVkRnJvbVBhdGgoKSB7XG4gICAgdGhpcy52aXNpdGVkID0gbmV3IFNldCh0aGlzLnBhdGgubWFwKChwb2ludCkgPT4ga2V5T2YocG9pbnQpKSk7XG4gIH1cblxuICB2aXNpdChwb2ludDogWmlwUHV6emxlUG9pbnQpOiBWaXNpdFJlc3VsdCB7XG4gICAgaWYgKHBvaW50LnJvdyA8IDAgfHwgcG9pbnQuY29sIDwgMCB8fCBwb2ludC5yb3cgPj0gdGhpcy5zaXplIHx8IHBvaW50LmNvbCA+PSB0aGlzLnNpemUpIHtcbiAgICAgIHJldHVybiB7IGNoYW5nZWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnN1cmVTdGFydChwb2ludCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdCA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3Qucm93ID09PSBwb2ludC5yb3cgJiYgbGFzdC5jb2wgPT09IHBvaW50LmNvbCkge1xuICAgICAgcmV0dXJuIHsgY2hhbmdlZDogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNBZGphY2VudChsYXN0LCBwb2ludCkpIHtcbiAgICAgIHJldHVybiB7IGNoYW5nZWQ6IGZhbHNlLCBpbnZhbGlkS2V5OiBrZXlPZihwb2ludCkgfTtcbiAgICB9XG5cbiAgICBjb25zdCBjZWxsS2V5ID0ga2V5T2YocG9pbnQpO1xuXG4gICAgaWYgKHRoaXMudmlzaXRlZC5oYXMoY2VsbEtleSkpIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMucGF0aC5sZW5ndGggLSAxO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IGxhc3RJbmRleCAtIDE7XG4gICAgICBpZiAocHJldmlvdXNJbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5wYXRoW3ByZXZpb3VzSW5kZXhdO1xuICAgICAgICBpZiAocHJldmlvdXMucm93ID09PSBwb2ludC5yb3cgJiYgcHJldmlvdXMuY29sID09PSBwb2ludC5jb2wpIHtcbiAgICAgICAgICB0aGlzLnBhdGgucG9wKCk7XG4gICAgICAgICAgdGhpcy5yZXNldFZpc2l0ZWRGcm9tUGF0aCgpO1xuICAgICAgICAgIHRoaXMuaGFzQmFja3RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVjb21wdXRlQW5jaG9ycygpO1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJhY3RpdmVcIjtcbiAgICAgICAgICByZXR1cm4geyBjaGFuZ2VkOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGNoYW5nZWQ6IGZhbHNlLCBpbnZhbGlkS2V5OiBjZWxsS2V5IH07XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3JzQnlLZXkuZ2V0KGNlbGxLZXkpO1xuICAgIGNvbnN0IG5leHRBbmNob3IgPSB0aGlzLmFuY2hvcnNbdGhpcy5hbmNob3JJbmRleCArIDFdO1xuICAgIGlmIChhbmNob3IpIHtcbiAgICAgIGlmICghbmV4dEFuY2hvciB8fCBhbmNob3IudmFsdWUgIT09IG5leHRBbmNob3IudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZDogZmFsc2UsIGludmFsaWRLZXk6IGNlbGxLZXkgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBhdGgucHVzaChwb2ludCk7XG4gICAgdGhpcy52aXNpdGVkLmFkZChjZWxsS2V5KTtcbiAgICBpZiAoYW5jaG9yICYmIG5leHRBbmNob3IgJiYgYW5jaG9yLnZhbHVlID09PSBuZXh0QW5jaG9yLnZhbHVlKSB7XG4gICAgICB0aGlzLmFuY2hvckluZGV4ICs9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhdGgubGVuZ3RoID09PSB0aGlzLnRvdGFsQ2VsbHMgJiYgdGhpcy5hbmNob3JJbmRleCA9PT0gdGhpcy5hbmNob3JzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJ3b25cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0dXMgPSBcImFjdGl2ZVwiO1xuICAgIH1cbiAgICByZXR1cm4geyBjaGFuZ2VkOiB0cnVlIH07XG4gIH1cblxuICB1bmRvKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnBhdGgubGVuZ3RoIDw9IDEpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLnBhdGgucG9wKCk7XG4gICAgdGhpcy5yZXNldFZpc2l0ZWRGcm9tUGF0aCgpO1xuICAgIHRoaXMuaGFzQmFja3RyYWNrZWQgPSB0cnVlO1xuICAgIHRoaXMucmVjb21wdXRlQW5jaG9ycygpO1xuICAgIHRoaXMuc3RhdHVzID0gXCJhY3RpdmVcIjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldFNuYXBzaG90KCk6IFppcFNuYXBzaG90IHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogWy4uLnRoaXMucGF0aF0sXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgaGFzQmFja3RyYWNrZWQ6IHRoaXMuaGFzQmFja3RyYWNrZWRcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1c2VaaXBQdXp6bGVFbmdpbmUgPSAocHV6emxlOiBaaXBQdXp6bGVEYXRhKSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHVzZU1lbW8oKCkgPT4gSlNPTi5zdHJpbmdpZnkocHV6emxlKSwgW3B1enpsZV0pO1xuICBjb25zdCBlbmdpbmVSZWYgPSB1c2VSZWY8WmlwUHV6emxlRW5naW5lPigpO1xuICBjb25zdCBbLCBmb3JjZVJlbmRlcl0gPSB1c2VTdGF0ZSgwKTtcblxuICBpZiAoIWVuZ2luZVJlZi5jdXJyZW50KSB7XG4gICAgZW5naW5lUmVmLmN1cnJlbnQgPSBuZXcgWmlwUHV6emxlRW5naW5lKHB1enpsZSwgc2lnbmF0dXJlKTtcbiAgfSBlbHNlIGlmIChlbmdpbmVSZWYuY3VycmVudC5zaWduYXR1cmUgIT09IHNpZ25hdHVyZSkge1xuICAgIGVuZ2luZVJlZi5jdXJyZW50LnNldFB1enpsZShwdXp6bGUsIHNpZ25hdHVyZSk7XG4gIH1cblxuICBjb25zdCB2aXNpdCA9IHVzZUNhbGxiYWNrKFxuICAgIChwb2ludDogWmlwUHV6emxlUG9pbnQpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVuZ2luZVJlZi5jdXJyZW50Py52aXNpdChwb2ludCk7XG4gICAgICBpZiAocmVzdWx0Py5jaGFuZ2VkKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCh2YWx1ZSkgPT4gdmFsdWUgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBbXVxuICApO1xuXG4gIGNvbnN0IHVuZG8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGVuZ2luZVJlZi5jdXJyZW50Py51bmRvKCkpIHtcbiAgICAgIGZvcmNlUmVuZGVyKCh2YWx1ZSkgPT4gdmFsdWUgKyAxKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIHNpemU6IHB1enpsZS5zaXplLFxuICAgIGFuY2hvcnM6IGVuZ2luZVJlZi5jdXJyZW50LmFuY2hvcnMsXG4gICAgc25hcHNob3Q6IGVuZ2luZVJlZi5jdXJyZW50LmdldFNuYXBzaG90KCksXG4gICAgdmlzaXQsXG4gICAgdW5kb1xuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImtleU9mIiwicG9pbnQiLCJyb3ciLCJjb2wiLCJaaXBQdXp6bGVFbmdpbmUiLCJzZXRQdXp6bGUiLCJwdXp6bGUiLCJzaWduYXR1cmUiLCJhbmNob3JzIiwic29ydCIsImEiLCJiIiwidmFsdWUiLCJhbmNob3JLZXlzIiwibWFwIiwiYW5jaG9yIiwiYW5jaG9yc0J5S2V5IiwiTWFwIiwic2l6ZSIsInRvdGFsQ2VsbHMiLCJwYXRoIiwidmlzaXRlZCIsIlNldCIsImFuY2hvckluZGV4Iiwic3RhdHVzIiwiaGFzQmFja3RyYWNrZWQiLCJpc0FkamFjZW50IiwiTWF0aCIsImFicyIsImVuc3VyZVN0YXJ0IiwiZmlyc3RBbmNob3IiLCJjaGFuZ2VkIiwiaW52YWxpZEtleSIsInJlY29tcHV0ZUFuY2hvcnMiLCJmb3JFYWNoIiwiYW5jaG9ySWR4IiwiaW5kZXhPZiIsInJlc2V0VmlzaXRlZEZyb21QYXRoIiwidmlzaXQiLCJsZW5ndGgiLCJsYXN0IiwiY2VsbEtleSIsImhhcyIsImxhc3RJbmRleCIsInByZXZpb3VzSW5kZXgiLCJwcmV2aW91cyIsInBvcCIsImdldCIsIm5leHRBbmNob3IiLCJwdXNoIiwiYWRkIiwidW5kbyIsImdldFNuYXBzaG90IiwiY29uc3RydWN0b3IiLCJ1c2VaaXBQdXp6bGVFbmdpbmUiLCJKU09OIiwic3RyaW5naWZ5IiwiZW5naW5lUmVmIiwiZm9yY2VSZW5kZXIiLCJjdXJyZW50IiwicmVzdWx0Iiwic25hcHNob3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/games/zipPuzzle/ZipPuzzleLogic.ts\n"));

/***/ })

});